#!/usr/bin/env python3

import sys
import re
import fileinput
import pandas as pd
import argparse
import numpy as np


# Generate forest output statistics.
# Calculates the total number of prize and hidden nodes in the optimal forest,
# the average degrees of hidden and prize nodes, and the percentage of prize nodes
# that are included in the optimal forest


def get_stats(results_path):
    # Parse the total number of prize nodes out of the result info file
    with open(results_path + "result_info.txt", 'r') as f:
        lines = f.readlines()
            
    r = re.compile('There were [0-9]* terminals in the interactome')
    total_line = [line for line in lines if r.match(line)][0]
    total_prize_nodes = [int(s) for s in total_line.split()
                         if s.isdigit()][0]

    # Read in the list of nodes and the edges connecting them
    edge_attr = pd.read_csv(results_path + "result_edgeattributes.tsv",
                                  sep="\t")
    node_attr = pd.read_csv(results_path + "result_nodeattributes.tsv",
                                  sep="\t")

    # The forest generated by the steiner tree algorithm can be empty
    if node_attr.empty:
        return "Empty forest.\n"
    
    # Nodes are either prize nodes or hidden. In the input file, this is
    # specified as "Proteomic" or NaN. Change it to "Prize" and "Hidden".
    node_attr.TerminalType = node_attr.TerminalType.apply(lambda x:
                                                          "Prize" if
                                                          x == "Proteomic"
                                                          else "Hidden")

    # Parse out the source and target of each edge
    edge_attr["source"] = edge_attr.Edge.apply(lambda x:
                                                          x.split(' ')[0])
    edge_attr["target"] = edge_attr.Edge.apply(lambda x:
                                               x.split(' ')[2])

    
    def node_type(name):
        """Lookup if a node is hidden or prize based on associated gene name."""
        row = node_attr.loc[node_attr.Protein==name]
        return row.TerminalType.values[0]

    # For each edge, create columns for the source and target types
    edge_attr["source_type"] = edge_attr.source.apply(node_type)
    edge_attr["target_type"] = edge_attr.target.apply(node_type)

    # Count the number of prize and hidden nodes among sources and targets
    source_counts = edge_attr.source_type.value_counts()
    target_counts = edge_attr.target_type.value_counts()

    # Count the number of prize and hidden nodes among all nodes
    type_counts = node_attr.TerminalType.value_counts()
    pnodes_in_forest = type_counts.Prize
    hnodes_in_forest  = type_counts.Hidden

    # Percent of prize nodes included in the optimal forest
    percent_prize = pnodes_in_forest/total_prize_nodes

    # Calculate the average degree of prize and total nodes
    prize_total_degree = source_counts.Prize + target_counts.Prize
    hidden_total_degree = source_counts.Hidden + target_counts.Hidden
    avg_degree_prize = prize_total_degree/type_counts.Prize
    avg_degree_hidden = hidden_total_degree/type_counts.Hidden

    output = ["Total prize nodes: {}".format(total_prize_nodes),
              "Prize nodes in forest: {}".format(pnodes_in_forest),
              "Hidden nodes in optimal forest: {}".format(hnodes_in_forest),
              "Percent of prize nodes in forest: {0:.2%}".format(percent_prize),
              "Average degree of prize nodes: {0:.2f}".format(avg_degree_prize),
              "Average degree of hidden nodes: {0:.2f}\n".format(avg_degree_hidden)]

    return "\n".join(output)


if __name__ =="__main__":
    np.warnings.filterwarnings("ignore")
    parser = argparse.ArgumentParser(description="Generate output statistics for forest")
    parser.add_argument("results_path")
    args = parser.parse_args()
    results_path = args.results_path
    sys.stdout.write(get_stats(results_path))




    

    

    

    
